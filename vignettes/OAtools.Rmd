---
title: "Analyzing OpenArray Gene Expression Data with OAtools"
author: "Aidan Shea"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    toc_float: true
    fig_width: 5
    df_print: kable
vignette: >
  %\VignetteIndexEntry{Analyzing OpenArray Gene Expression Data with OAtools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

## Introduction

Highly multiplex PCR platforms enable drastically greater throughput compared 
to traditional PCR methods, making them critical for pathogen detection and 
gene expression experiments in public health and clinical research environments.
One such platform is ThermoFisher Scientific's OpenArray Technology, which our 
lab uses to screen patient swabs for respiratory viral infections. With 3000+ 
qPCR reactions taking place on each OpenArray plate, the sheer volume of data 
produced requires an informatic solution for downstream analyses and reporting.

ThermoFisher provides the proprietary QuantStudio 12K Flex Software and the 
Relative Quantification Application for data analysis. However, no all-in-one
open-source software exists to derive reportable results from raw fluorescence 
values measured on OpenArray.

To bridge the gap, OAtools streamlines the analysis process including data 
import, plotting and quality control, analysis, and communication through an 
R Markdown document. Our goal in sharing OAtools is to support open-source and 
shareable analyses of OpenArray gene expression data, especially in clinical 
research environments.

## Installation

### GitHub Install

To install the development version of *OAtools* directly from the 
uwvirology-ngs public GitHub, (<https://github.com/uwvirology-ngs/OAtools>) 
run the commands below in your R console:

```{r installation-dev, eval=FALSE}
# Install devtools from CRAN
if (!require("devtools", quietly = TRUE)) {
    install.packages("devtools")
}

# Install the development version of OAtools from the UW Virology NGS GitHub
devtools::install_github(
    repo = "uwvirology-ngs/OAtools", 
    dependencies = TRUE, 
    build_vignettes = TRUE
)
```

### Bioconductor Install

Our lab plans to share this project as a Bioconductor package. Once available, 
this package may be installed from Bioconductor by running the following 
commands in the R console:

```{r installation-bioconductor, eval=FALSE}
# install Bioconductor from CRAN
if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

# install OAtools from Bioconductor
BiocManager::install("OAtools")
```

### Environment Setup

If following along with the vignette by running code blocks in the R console, 
attach the `OAtools` and `SummarizedExperiment` libraries to the environment.
The `SummarizedExperiment` package should already be installed as a dependency.

```{r libraries, message=FALSE}
# attach OAtools and SummarizedExperiment libraries
library(OAtools)
library(SummarizedExperiment)
```

If it is not installed, install dplyr with the following:
```{r install-dplyr, eval=FALSE}
# install dplyr from CRAN
if (!require("dplyr", quietly = TRUE)) {
    install.packages("dplyr")
}
```

## Workflow Overview

*OAtools* supports two core methods for analyzing OpenArray qPCR data:

1.) The first method is to simply carry over the relative threshold analysis 
native to the QuantStudio 12K Flex Software.

2.) The second method is to fit a logistic model to the fluroescence vs. cycle 
data for each individual well, then determine PCR results based on the model 
parameters.

## Import to SummarizedExperiment

To start, we specify the filepath to some example OpenArray qPCR run data, 
which is included with the package. This data is a sample from a gene expression
experiment our lab, the University of Washington Virology Lab, ran on human 
nasal swabs to screen for respiratory pathogens. 

With the filepath specified, we use the `excelToSE()` 
function to read the .xlsx file containing the run data and load it into a 
SummarizedExperiment object. SummarizedExperiment is an S4 Class from 
Bioconductor used to stored matrix-like assay data and associated metadata. Note
that we specify the number of rows to read from the 'Results' tab of the .xlsx 
file with the num_results parameter. 

```{r data_import}
# save filepath to example OpenArray gene expression run data
path = system.file(
    "extdata", 
    "oa_gene_expression_1.xlsx", 
    package = "OAtools"
)

# transform the run data into a SummarizedExperiment
se <- excelToSE(excel_path = path)
```

## Experiment Structure

### Assay Matrix

With the data loaded into a SummarizedExperiment container, we can review its 
structure. The assay matrix stores the observed fluorescence values measured
by the QuantStudio 12K Flex thermocycler for every cycle within each 
though-hole on the OpenArray plate. We may access the assay matrix from 
our SummarizedExperiment object by invoking `assay(se)` and coercing 
the assay matrix into a dataframe with `as.data.frame()`.

If we want to be more explicit, we can also call `assays(se)$fluo_reporter` 
to retrieve the observed fluorescence values, which is useful when we add more 
assay matrices downstream. Here we display a slice of the fluorescence data 
from cycles 11 to 20; notice that the rows represent cycle number and the 
columns represent individual through-holes on the OpenArray plate. 

```{r structure-assay_matrix}
# retrieve the assay matrix and display a subset as a data frame
as.data.frame(assays(se)$fluo_reporter) |> 
    dplyr::select(well_2321:well_2386) |>
    dplyr::slice(11:20)
```

### Coldata

Other than raw fluorescence values, data associated with each PCR reaction 
on the OpenArray plate are stored in the colData of the SummarizedExperiment. 
We can access the colData with `as.data.frame(colData(se))`, again coercing 
to a data frame to display. Information stored here includes PCR results in the
form of a Crt and an Amp Score, metadata such as reporter dye and quencher, 
and QC metrics like Amp Score and Cq Conf. 

In particular, the Crt is a relative threshold value, which is anologous to a 
Ct value in a typical qPCR assay. The Amp Score is the final result assigned 
to the well automatically by QuantStudio 12K Flex Software. Here we display
a selection of the colData associated with the first 10 wells. 

```{r structure-coldata}
# retrieve the coldata and render a subset as a data frame
as.data.frame(colData(se)) |> 
    dplyr::select(
        well, sample_name:target_name, reporter, crt, amp_score:amp_status
    ) |> 
    dplyr::slice(1:10)
```

### Rowdata

By contrast, the rowData stores only the cycle numbers, which is less 
interesting by itself. 

```{r structure-rowdata}
# retrieve the rowdata and render a subset as a data frame
as.data.frame(rowData(se)) |> 
    dplyr::slice(1:10)
```

## Reporting Results

If we intend to use the relative threshold analysis native to the instrument 
software, we can create a run result report straight away. We can call the 
`generateReport()` function directly on the Summarized Experiment, which then 
dynamically generates a .html document summarizing the results. 

Note that the package *kableExtra* is required to generate the PCR report. 
If it is not installed, install with:

```{r install-kableExtra, eval=FALSE}
# install kableExtra from CRAN
if (!require("kableExtra", quietly = TRUE)) {
    install.packages("kableExtra")
}
```

The following code block generates the PCR report assuming that data has been
loaded in using `excelToSE()`. Note that it does not 
automatically execute when constructing this vignette as the function calls 
code to save the report directly to the user's machine. 

```{r reporting-results, eval=FALSE}
# generate a .html report from the run data
generateReport(se = se)
```

## Analysis by Logistic Regression

In alignment with open science and reproducible data analyses, OAtools supports 
an alternative method to derive sample results by fitting logistic models to 
the fluorescence curves of each PCR reaction on the OpenArray plate. The 
parameters of the model curve can be used to determine the result of each PCR 
reaction. In particular, OAtools calls an algorithm from SciPy to fit a 
5-parameter logistic regression to each fluorescence curve; we chose the 5PL 
model for its ability to handle asymmetries common to PCR curves. 

### Data Import

Here we start the data analysis again from the point where we have exported 
the gene expression experiment from QuantStudio 12K Flex software. As in the 
previous example, we load the experiment into a SummarizedExperiment object. 

```{r regression-data_import}
# clear the environment
rm(list = ls())

# save filepath to example OpenArray gene expression run data
path = system.file(
    "extdata", 
    "oa_gene_expression_1.xlsx", 
    package = "OAtools"
)

# transform the run data into a SummarizedExperiment
se <- excelToSE(excel_path = path)
```

### Optimizing Models to PCR Curves

The next step is to run the optimizer and fit a 5PL model curve to each PCR 
reaction on the OpenArray plate. OAtools exports the `fitModelsToSE()`
function, which iterates over experiment and optimizes such a model to each 
fluorescence curve. The function then computes features of the model from the 
parameters of best fit and appends them to the coldata of the 
SummarizedExperiment. 

Under the hood, `fitModelsToSE()` invokes the `runFitCurve`()` function, 
which is an R wrapper around the internal `fit_curve()` function implemented in 
python3. `fit_curve()` runs the optimizer and returns the model when provided 
fluorescence vs. cycle data as a data frame for a single PCR reaction.

Among the features appended by `fitModelsToSe()` are the slope at the 
midpoint of the reaction and the overall change in fluorescence, both of which 
are relevant indicators of the PCR result. Note that we include a
linear_threshold parameter when calling the function. PCR curves with overall 
change in fluorescence below the linear_threshold parameter are marked as 
negative and fit to a linear model instead. 

The rationale is that PCR curves with very low overall change in fluorescence 
are trivially negative, but take significantly longer for the optimizer to 
handle when attempting to fit a model. Thus, it saves on compute time to 
automatically filter out such curves. 

```{r regression-fit_curve}
# optimize model curves to each PCR reaction append model parameters and
# features to the SummarizedExperiment
se <- fitModelsToSE(
    se = se,
    linear_threshold = 500
)

# render a snapshot of the coldata collapsed to unique reactions
as.data.frame(SummarizedExperiment::colData(se)) |> 
    dplyr::select(
        well, 
        sample_name:target_name, 
        regression_type, 
        midpoint_cycle:delta_fluo
    ) |> 
    dplyr::slice_head(n = 10)
```

### Deriving PCR Results from the Model

The next step is to use the model parameters and features we've retrieved to 
derive PCR results. We can invoke the `assignCallsToSE()` function on our
SummarizedExperiment to do this programmatically. `assignCallsToSE()` 
accepts as input the SummarizedExperiment and an excel key (.xlsx) associating
each assay target with threshold values for relevant model features. In 
particular, the excel must specify values for cycle threshold, slope at the 
reaction midpoint, and overall change-in-fluorescence.

For more details on the key, run `?OAtools::target_threshold_key` in the R 
console. 

The outcome of running the `assignCallsToSe()` function is to add columns 
indicating whether the PCR reaction clears each threshold, then a column 
indicating the final PCR result. The rationale for allowing different thresholds
for each assay on the OpenArray plate is that fluorescence curve shape may vary 
by assay due to differences in primer efficiency. As a highly multiplex 
platform, numerous assays are typically present on the same OpenArray plate. 

```{r regression-derive_results}
# save filepath to target-threshold-key
key_path = system.file(
    "extdata", 
    "target_threshold_key.xlsx", 
    package = "OAtools"
)

# assign a PCR result according to the key
se <- assignCallsToSE(
    se = se, 
    key_path = key_path
)

# render a snapshot including the logic for determining the result
as.data.frame(SummarizedExperiment::colData(se)) |> 
    dplyr::select(
        well, crt, midpoint_slope, delta_fluo, 
        crt_threshold, slope_threshold, delta_threshold, result
    ) |> 
    dplyr::slice_head(n = 10)
```

## Interoperability

### NormqPCR

*OAtools* supports interoperability with the NormqPCR package from Bioconductor,
which provides functions to normalize RT-qPCR data from gene expression 
platforms like OpenArray. *NormqPCR* reads from the qPCRBatch class object, 
which requires the *ReadqPCR* package. We can set up our environment as below:

```{r interop-NormqPCR_setup, message=FALSE, eval=FALSE}
# Install ReadqPCR from Bioconductor
if (!require("ReadqPCR", quietly = TRUE)) {
    BiocManager::install("ReadqPCR")
}

# Install NormqPCR from Bioconductor
if (!require("NormqPCR", quietly = TRUE)) {
    BiocManager::install("ReadqPCR")
}
```

Then, to convert the SummarizedExperiment container into a *NormqPCR*-friendly 
instance of the qPCRBatch class, simply invoke the `seToQPCRBatch()` function
on the SummarizedExperiment container. With our qPCRBatch object, we can, for
example, normalize the cycle thresholds against a housekeeping gene.

```{r interop-NormqPCR}
# convert SummarizedExperiment container to qPCRBatch
qpcr <- seToQPCRBatch(se)

# choose housekeeping gene (in this case, the RNAse P control)
housekeeping_gene = "RNAse_P_Pa04930436_g1"

# run delta-Cq calculation
norm <- NormqPCR::deltaCq(
    qPCRBatch = qpcr,
    hkgs = housekeeping_gene
)

# display expression matrix
as.data.frame(Biobase::exprs(norm)) |> 
    dplyr::select(`Pos_Control_A`:`Sample-106`) |> 
    knitr::kable(digits = 2)
    
```

Please refer to the official documentation for *NormqPCR* for more information.
(<https://bioconductor.org/packages/release/bioc/html/NormqPCR.html>) 


## Session Info

```{r sessionInfo}
sessionInfo()
```

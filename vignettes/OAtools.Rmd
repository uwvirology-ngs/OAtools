---
title: "OAtools"
output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{1. OAtools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r libraries, include=FALSE}
library(OAtools)
library(SummarizedExperiment)
```

## Introduction

Highly multiplex PCR platforms enable drastically greater throughput compared 
to traditional PCR methods, making them critical for pathogen detection and 
gene expression experiments in public health and clinical research environments.
One such platform is ThermoFisher Scientific's OpenArray Technology, which our 
lab uses to screen patient swabs for respiratory viral infections. With 3000+ 
qPCR reactions taking place on each OpenArray plate, the sheer volume of data 
produced requires an informatic solution for downstream analyses and reporting.

ThermoFisher provides the proprietary QuantStudio 12K Flex Software and the 
Relative Quantification Application for data analysis. However, no all-in-one
open-source software exists to derive reportable results from raw fluorescence 
values measured on OpenArray.

To bridge the gap, OAtools streamlines the analysis process including data 
import, plotting and quality control, analysis, and communication through an 
R Markdown document. Our goal in sharing OAtools is to support open-source and 
shareable analyses of OpenArray gene expression data, especially in clinical 
research environments.

## Installation

To install the development version of *OAtools* directly from the 
uwvirology-ngs public GitHub, (<https://github.com/uwvirology-ngs/OAtools>) 
run the commands below in your R console:

```{r pak-install, eval=FALSE}
# install OAtools from the uwvirology-ngs GitHub
pak::pak("uwvirology-ngs/OAtools")
```

Our lab plans to share this project as a Bioconductor package. Once available, 
this package may be installed from Bioconductor by running the following 
commands in the R console:

```{r bioconductor-install, eval=FALSE}
# if needed, install Bioconductor
if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

# install OAtools from Bioconductor
BiocManager::install("OAtools")
```

## General Workflow

### Overview

*OAtools* supports two core methods for analyzing OpenArray qPCR data:

1.) The first method is to simply carry over the relative threshold analysis 
native to the QuantStudio 12K Flex Software.

2.) The second method is to fit a logistic model to the fluroescence vs. cycle 
data for each individual well, then determine PCR results based on the model 
parameters.

### Method 1 - Relative Threshold Analysis

To start, we specify the filepath to some example OpenArray qPCR run data, 
which is included with the package. This data is a sample from a gene expression
experiment our lab, the University of Washington Virology Lab, ran on human 
nasal swabs to screen for respiratory pathogens. 

With the filepath specified, we use the excel_to_summarized_experiment() 
function to read the .xlsx file containing the run data and load it into a 
SummarizedExperiment object. SummarizedExperiment is an S4 Class from 
Bioconductor used to stored matrix-like assay data and associated metadata. Note
that we specify the number of rows to read from the 'Results' tab of the .xlsx 
file with the num_results parameter. 

```{r method1-load_data}
# save filepath to example OpenArray gene expression run data
path = system.file(
    "extdata", 
    "oa_gene_expression_batch1.xlsx", 
    package = "OAtools"
)

# transform the run data into a SummarizedExperiment
se <- excel_to_summarized_experiment(
    path = path, 
    num_results = 96
)
```

With the data loaded into a SummarizedExperiment container, we can review its 
structure. The assay matrix stores the observed fluorescence values measured
by the QuantStudio 12K Flex thermocycler for every cycle within each 
though-hole on the OpenArray plate. We may access the assay matrix from 
our SummarizedExperiment object by invoking `assay(se)` and coercing 
the assay matrix into a dataframe with `as.data.frame()`.

If we want to be more explicit, we can also call `assays(se)$fluo` to retrieve 
the observed fluorescence values, which is useful when we add more assay 
matrices downstream. Here we display a slice of the fluorescence data from 
cycles 11 to 20; notice that the rows represent cycle number and the columns 
represent individual through-holes on the OpenArray plate. 

```{r method1-2}
as.data.frame(assays(se)$fluo) |> 
    dplyr::select(well_2321:well_2386) |>
    dplyr::slice(11:20) |> 
    knitr::kable(format = "markdown")
```

Other than raw fluorescence values, data associated with each PCR reaction 
on the OpenArray plate are stored in the colData of the SummarizedExperiment. 
We can access the colData with `as.data.frame(colData(se))`, again coercing 
to a data frame to display. Information stored here includes PCR results in the
form of a Crt and an Amp Score, metadata such as reporter dye and quencher, 
and QC metrics like Amp Score and Cq Conf. 

In particular, the Crt is a relative threshold value, which is anologous to a 
Ct value in a typical qPCR assay. The Amp Score is the final result assigned 
to the well automatically by QuantStudio 12K Flex Software. Here we display
a selection of the colData associated with the first 10 wells. 

```{r method1-3}
run_data <- as.data.frame(colData(se))

# print a slice of the SummarizedExperiment
run_data |> 
    dplyr::select(
        well, sample_name:target_name, reporter, crt, amp_score:amp_status) |> 
    dplyr::slice(1:10) |> 
    knitr::kable(format = "markdown")
```

By contrast, the rowData stores only the cycle numbers, which is less 
interesting by itself. 

If we intend to use the relative threshold analysis native to the instrument 
software, we can generate a run result report directly. This line generates 
an html report and saves it to the working directory.

```{r method1-report_data, eval=FALSE}
# generate a .html report from the tidy_run_data
generate_report_from_se(se = se, path = ".")
```

### Method 2 - Curve Fitting

If we intend to use the curve-fitting approach to analyze the data, the 
initial step of loading the run data into tibble format is the same.

```{r method2-load_data}
# save filepath to example OpenArray gene expression run data
path = system.file(
    "extdata", 
    "oa_gene_expression_batch1.xlsx", 
    package = "OAtools"
)

# transform the run data into a SummarizedExperiment
se <- excel_to_summarized_experiment(path = path, num_results = 96)
```

However, we must now optimize the 5-parameter logistic regression to each 
fluorescence curve and add extracted features to the data. The 
fit_models_to_se() function adds extracted features such as the overall 
change-in-fluorescence and the slope at the midpoint of the reaction to the 
input data. This function is powered by SciPy for model optimization and is 
the most computationally expensive of the package, so it may take a moment to 
run. To speed up processing and prevent overflow errors, reactions with 
overall change-in-fluorescence below the linear_threshold parameter are 
considered trivially negative and fit to linear models instead.

```{r method2-modify_data}
# optimize 5PL/linear models to each curve and append to the dataset
se <- fit_models_to_se(
    se = se,
    linear_threshold = 500
)

# print a snapshot of the dataset collapsed to unique reactions
curve_fit_data <- as.data.frame(SummarizedExperiment::colData(se))
curve_fit_data |> 
    dplyr::select(
        well, 
        sample_name:target_name, 
        regression_type, 
        x_mid:delta
    ) |> 
    dplyr::distinct(well, .keep_all = TRUE) |> 
    dplyr::slice_head(n = 10) |> 
    knitr::kable(format = "markdown")
```

The next step is to assign results based off of the extracted features. The 
assign_calls_to_se() function accepts a .xlsx file that associates each 
assay target with user-selected thresholds for cycle threshold, midpoint 
slope, and overall change-in-fluorescence that determine whether amplification 
in the well is interpreted as positive or negative. For more details, 
run ?OAtools::target_threshold_key in the R console.

```{r method2-interpret_data}
# save filepath to target-threshold-key
key_path = system.file(
    "extdata", 
    "target_threshold_key.xlsx", 
    package = "OAtools"
)

# assign results based on the key and append to the data frame
se <- assign_calls_to_se(
    se = se, 
    key_path = key_path
)

# print a snapshot including the logic for determining the result
result_data <- as.data.frame(SummarizedExperiment::colData(se))
result_data |> 
    dplyr::select(well, x_mid:delta, slope_threshold:crt_threshold, result) |> 
    dplyr::distinct(well, .keep_all = TRUE) |> 
    dplyr::slice_head(n = 10) |> 
    knitr::kable(format = "markdown")
```

```{r sessionInfo}
sessionInfo()
```
